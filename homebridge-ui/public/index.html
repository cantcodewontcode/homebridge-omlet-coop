<style>
  .card {
    padding: 20px;
    background: #fff;
    border-radius: 8px;
    margin-bottom: 20px;
  }
  .form-group {
    margin-bottom: 15px;
    position: relative;
  }
  .form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
  }
  .password-wrapper {
    position: relative;
  }
  .password-toggle {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    color: #6c757d;
  }
  .password-toggle:hover {
    color: #495057;
  }
  .form-control {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
  }
  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
  }
  .btn-primary {
    background: #007bff;
    color: white;
  }
  .btn-primary:hover {
    background: #0056b3;
  }
  .btn-primary:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }
  .btn-link {
    background: none;
    border: none;
    color: #007bff;
    cursor: pointer;
    font-size: 14px;
    padding: 0;
    text-decoration: none;
    font-weight: 500;
  }
  .btn-link:hover {
    text-decoration: underline;
  }
  .device-list {
    margin-top: 20px;
  }
  .device-item {
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
    margin-bottom: 10px;
  }
  .device-item h4 {
    margin: 0 0 5px 0;
    font-size: 16px;
  }
  .device-item p {
    margin: 0;
    font-size: 13px;
    color: #666;
  }
  .status-message {
    padding: 12px;
    border-radius: 4px;
    margin-bottom: 15px;
  }
  .status-success {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }
  .status-error {
    background: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }
  .status-info {
    background: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
  }
  .hidden {
    display: none;
  }
  small {
    display: block;
    margin-top: 2px;
    line-height: 1.3;
  }
  .field-error {
    color: #dc3545;
    font-size: 12px;
    margin-top: 4px;
    display: none;
  }
  .field-error.show {
    display: block;
  }
</style>

<div class="card">
  <h3>Omlet Coop Setup</h3>
  <p>Enter your Omlet account credentials to automatically configure your plugin.</p>
  
  <div id="statusMessage" class="hidden"></div>
  
  <div id="loginForm">
    <div class="form-group">
      <label for="email">Email Address</label>
      <input type="email" class="form-control" id="email" placeholder="your@email.com" pattern="[^\s@]+@[^\s@]+\.[^\s@]+">
      <div class="field-error" id="emailError"></div>
    </div>
    
    <div class="form-group">
      <label for="password">Password</label>
      <div class="password-wrapper">
        <input type="password" class="form-control" id="password" placeholder="">
        <button type="button" class="password-toggle" onclick="togglePasswordVisibility()">
          <svg id="eyeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="form-group">
      <label for="countryCode">Country Code</label>
      <select class="form-control" id="countryCode" required>
        <option value="AU">AU - Australia</option>
        <option value="DK">DK - Denmark</option>
        <option value="FR">FR - France</option>
        <option value="DE">DE - Germany</option>
        <option value="IT">IT - Italy</option>
        <option value="IE">IE - Ireland</option>
        <option value="NL">NL - Netherlands</option>
        <option value="SE">SE - Sweden</option>
        <option value="UK">UK - United Kingdom</option>
        <option value="US" selected>US - United States</option>
      </select>
    </div>
    
    <div class="form-group">
      <label>
        <input type="checkbox" id="enableLight" checked> Enable Coop Light Accessory
      </label>
      <small style="color: #6c757d;">Uncheck if you do not have the Omlet coop light module</small>
    </div>
    
    <!-- Advanced Settings Section -->
    <div style="margin-top: 25px; margin-bottom: 15px;">
      <button type="button" class="btn-link" onclick="toggleAdvanced()" style="background: none; border: none; color: #007bff; cursor: pointer; font-size: 14px; padding: 0; text-decoration: none;">
        <span id="advancedToggle">▶</span> Advanced Settings
      </button>
    </div>
    
    <div id="advancedSection" class="hidden" style="padding: 15px; background: #f8f9fa; border-radius: 6px; margin-bottom: 15px;">
      <div class="form-group">
        <label for="apiServer">API Server</label>
        <input type="text" class="form-control" id="apiServer" placeholder="x107.omlet.co.uk" pattern="[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*">
        <small style="color: #6c757d;">Default: x107.omlet.co.uk</small>
        <div class="field-error" id="apiServerError"></div>
      </div>
      
      <div class="form-group">
        <label for="manualToken">API Token</label>
        <input type="text" class="form-control" id="manualToken" placeholder="optional, will be auto-discovered" pattern="[a-zA-Z0-9]{1,64}">
        <small style="color: #6c757d;">Provide API token instead of email address and password, if desired.</small>
        <div class="field-error" id="manualTokenError"></div>
      </div>
      
      <div class="form-group">
        <label for="manualDeviceId">Device ID</label>
        <input type="text" class="form-control" id="manualDeviceId" placeholder="optional, will be auto-discovered" pattern="[a-zA-Z0-9]{1,32}">
        <small style="color: #6c757d;">Provide Device ID to skip coop door auto-discovery, or to specify a coop door if you have multiple doors.</small>
        <div class="field-error" id="manualDeviceIdError"></div>
      </div>
      
      <div class="form-group">
        <label for="pollInterval">Poll Interval (seconds)</label>
        <input type="number" class="form-control" id="pollInterval" placeholder="30" min="30" max="300" step="1">
        <small style="color: #6c757d;">How often to check device status (30-300 seconds)</small>
        <div class="field-error" id="pollIntervalError"></div>
      </div>
      
      <div class="form-group">
        <label>
          <input type="checkbox" id="enableBattery"> Enable Battery Status
        </label>
        <small style="color: #6c757d;">Show battery level in Homebridge and third-party HomeKit apps (not visible in Apple Home app)</small>
      </div>
      
      <div class="form-group">
        <label>
          <input type="checkbox" id="debugMode"> Enable Debug Mode
        </label>
        <small style="color: #6c757d;">Enable detailed logging for troubleshooting</small>
      </div>
    </div>
    
    <button id="loginButton" class="btn btn-primary">Login</button>
  </div>
  
  <div id="devicesSection" class="hidden">
    <h4>Discovered Devices</h4>
    <div id="deviceList" class="device-list"></div>
  </div>
</div>

<script>
// Toggle advanced settings
function toggleAdvanced() {
  const section = document.getElementById('advancedSection');
  const toggle = document.getElementById('advancedToggle');
  
  if (section.classList.contains('hidden')) {
    section.classList.remove('hidden');
    toggle.textContent = '▼';
  } else {
    section.classList.add('hidden');
    toggle.textContent = '▶';
  }
}

// Toggle password visibility
function togglePasswordVisibility() {
  const passwordInput = document.getElementById('password');
  const eyeIcon = document.getElementById('eyeIcon');
  
  if (passwordInput.type === 'password') {
    passwordInput.type = 'text';
    // Eye with slash (hidden)
    eyeIcon.innerHTML = `
      <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
      <line x1="1" y1="1" x2="23" y2="23"></line>
    `;
  } else {
    passwordInput.type = 'password';
    // Eye without slash (visible)
    eyeIcon.innerHTML = `
      <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
      <circle cx="12" cy="12" r="3"></circle>
    `;
  }
}

(async () => {
  let currentConfig = null;
  let discoveredToken = null;
  let discoveredDevices = [];
  
  // Get current config
  try {
    const configs = await homebridge.getPluginConfig();
    currentConfig = configs && configs.length > 0 ? configs[0] : {};
  } catch (error) {
    console.error('Error loading config:', error);
    currentConfig = {};
  }
  
  // Pre-fill form if we have existing config
  if (currentConfig.email) {
    document.getElementById('email').value = currentConfig.email;
  }
  if (currentConfig.password) {
    document.getElementById('password').value = currentConfig.password;
  }
  if (currentConfig.countryCode) {
    document.getElementById('countryCode').value = currentConfig.countryCode;
  }
  
  // Pre-fill advanced settings
  if (currentConfig.apiServer) {
    document.getElementById('apiServer').value = currentConfig.apiServer;
  }
  if (currentConfig.bearerToken) {
    document.getElementById('manualToken').value = currentConfig.bearerToken;
  }
  if (currentConfig.deviceId) {
    document.getElementById('manualDeviceId').value = currentConfig.deviceId;
  }
  if (currentConfig.pollInterval) {
    document.getElementById('pollInterval').value = currentConfig.pollInterval;
  }
  if (currentConfig.debug) {
    document.getElementById('debugMode').checked = currentConfig.debug;
  }
  if (currentConfig.enableLight !== undefined) {
    document.getElementById('enableLight').checked = currentConfig.enableLight;
  }
  if (currentConfig.enableBattery !== undefined) {
    document.getElementById('enableBattery').checked = currentConfig.enableBattery;
  }
  
  // Auto-update config when form fields change (so built-in Save button works)
  async function updateConfigFromForm() {
    // Build config explicitly (don't spread currentConfig - causes clone errors)
    const updatedConfig = {
      name: currentConfig.name || 'Omlet Coop',
      platform: 'OmletCoop',
      email: document.getElementById('email').value.trim() || undefined,
      password: document.getElementById('password').value.trim() || undefined,
      countryCode: document.getElementById('countryCode').value,
      bearerToken: document.getElementById('manualToken').value.trim() || undefined,
      deviceId: document.getElementById('manualDeviceId').value.trim() || undefined,
      enableLight: document.getElementById('enableLight').checked,
      enableBattery: document.getElementById('enableBattery').checked,
      debug: document.getElementById('debugMode').checked
    };
    
    // Only include apiServer if user explicitly set it (not empty and not default)
    const apiServerValue = document.getElementById('apiServer').value.trim();
    if (apiServerValue && apiServerValue !== 'x107.omlet.co.uk') {
      updatedConfig.apiServer = apiServerValue;
    }
    
    // Only include pollInterval if user explicitly set it (not empty)
    const pollIntervalValue = document.getElementById('pollInterval').value.trim();
    if (pollIntervalValue) {
      updatedConfig.pollInterval = parseInt(pollIntervalValue);
    }
    
    // Remove undefined values to keep config clean
    Object.keys(updatedConfig).forEach(key => {
      if (updatedConfig[key] === undefined) {
        delete updatedConfig[key];
      }
    });
    
    await homebridge.updatePluginConfig([updatedConfig]);
  }
  
  // Add event listeners to all form fields
  document.getElementById('email').addEventListener('change', updateConfigFromForm);
  document.getElementById('password').addEventListener('change', updateConfigFromForm);
  document.getElementById('countryCode').addEventListener('change', updateConfigFromForm);
  document.getElementById('apiServer').addEventListener('change', updateConfigFromForm);
  document.getElementById('manualToken').addEventListener('change', updateConfigFromForm);
  document.getElementById('manualDeviceId').addEventListener('change', updateConfigFromForm);
  document.getElementById('pollInterval').addEventListener('change', updateConfigFromForm);
  document.getElementById('enableLight').addEventListener('change', updateConfigFromForm);
  document.getElementById('enableBattery').addEventListener('change', updateConfigFromForm);
  document.getElementById('debugMode').addEventListener('change', updateConfigFromForm);
  
  // Show status message
  function showStatus(message, type) {
    const statusDiv = document.getElementById('statusMessage');
    statusDiv.className = `status-message status-${type}`;
    statusDiv.textContent = message;
    statusDiv.classList.remove('hidden');
  }
  
  // Hide status message
  function hideStatus() {
    document.getElementById('statusMessage').classList.add('hidden');
  }
  
  // Client-side validation helper
  function validateInputs(email, apiServer, pollInterval) {
    let isValid = true;
    
    // Email validation (if provided)
    if (email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        showStatus('Please enter a valid email address', 'error');
        isValid = false;
      }
    }
    
    // API Server validation (if provided)
    if (apiServer && apiServer !== 'x107.omlet.co.uk') {
      const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      if (!hostnameRegex.test(apiServer)) {
        showStatus('Please enter a valid hostname for API Server', 'error');
        isValid = false;
      }
    }
    
    // Poll Interval validation (if provided)
    if (pollInterval) {
      const interval = parseInt(pollInterval);
      if (isNaN(interval)) {
        showStatus('Poll interval must be a number', 'error');
        isValid = false;
      } else if (interval < 30 || interval > 300) {
        showStatus('Poll interval must be between 30 and 300 seconds', 'error');
        isValid = false;
      }
    }
    
    return isValid;
  }
  
  // Real-time field validation
  function validateField(fieldId) {
    const field = document.getElementById(fieldId);
    const errorDiv = document.getElementById(fieldId + 'Error');
    const value = field.value.trim();
    
    // Clear any existing error styling
    field.style.borderColor = '';
    errorDiv.classList.remove('show');
    errorDiv.textContent = '';
    
    if (!value) {
      // Empty is OK for optional fields
      updateButtonStates();
      return true;
    }
    
    let isValid = true;
    let errorMsg = '';
    
    switch(fieldId) {
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        isValid = emailRegex.test(value);
        errorMsg = 'Invalid email address format';
        break;
        
      case 'apiServer':
        if (value === 'x107.omlet.co.uk') {
          // Default is always valid
          isValid = true;
        } else {
          const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
          isValid = hostnameRegex.test(value);
          errorMsg = 'Invalid hostname format';
        }
        break;
        
      case 'manualToken':
        const tokenRegex = /^[a-zA-Z0-9]{1,64}$/;
        isValid = tokenRegex.test(value);
        if (value.length > 64) {
          errorMsg = 'Token must be 64 characters or less';
        } else if (!/^[a-zA-Z0-9]+$/.test(value)) {
          errorMsg = 'Token must be alphanumeric only';
        } else {
          errorMsg = 'Invalid token format';
        }
        break;
        
      case 'manualDeviceId':
        const deviceIdRegex = /^[a-zA-Z0-9]{1,32}$/;
        isValid = deviceIdRegex.test(value);
        if (value.length > 32) {
          errorMsg = 'Device ID must be 32 characters or less';
        } else if (!/^[a-zA-Z0-9]+$/.test(value)) {
          errorMsg = 'Device ID must be alphanumeric only';
        } else {
          errorMsg = 'Invalid device ID format';
        }
        break;
        
      case 'pollInterval':
        const interval = parseInt(value);
        if (isNaN(interval)) {
          isValid = false;
          errorMsg = 'Must be a number';
        } else if (interval < 30 || interval > 300) {
          isValid = false;
          errorMsg = 'Must be between 30-300 seconds';
        }
        break;
    }
    
    if (!isValid) {
      field.style.borderColor = '#dc3545';
      errorDiv.textContent = errorMsg;
      errorDiv.classList.add('show');
    } else {
      field.style.borderColor = '#28a745';
    }
    
    updateButtonStates();
    return isValid;
  }
  
  // Update Login and Save button states based on validation
  function updateButtonStates() {
    // Don't disable the button - we'll check validation on click instead
    // Just keep track of validation state for when Login is clicked
  }
  
  // Add blur event listeners for real-time validation
  document.getElementById('email').addEventListener('blur', () => validateField('email'));
  document.getElementById('apiServer').addEventListener('blur', () => validateField('apiServer'));
  document.getElementById('manualToken').addEventListener('blur', () => validateField('manualToken'));
  document.getElementById('manualDeviceId').addEventListener('blur', () => validateField('manualDeviceId'));
  document.getElementById('pollInterval').addEventListener('blur', () => validateField('pollInterval'));
  
  // Also validate on input (as user types) for immediate feedback
  document.getElementById('email').addEventListener('input', () => {
    const field = document.getElementById('email');
    const errorDiv = document.getElementById('emailError');
    if (field.value.trim()) {
      setTimeout(() => validateField('email'), 500); // Debounce 500ms
    } else {
      field.style.borderColor = '';
      errorDiv.classList.remove('show');
      updateButtonStates();
    }
  });
  
  document.getElementById('apiServer').addEventListener('input', () => {
    const field = document.getElementById('apiServer');
    const errorDiv = document.getElementById('apiServerError');
    if (field.value.trim()) {
      setTimeout(() => validateField('apiServer'), 500);
    } else {
      field.style.borderColor = '';
      errorDiv.classList.remove('show');
      updateButtonStates();
    }
  });
  
  document.getElementById('manualToken').addEventListener('input', () => {
    const field = document.getElementById('manualToken');
    const errorDiv = document.getElementById('manualTokenError');
    if (field.value.trim()) {
      setTimeout(() => validateField('manualToken'), 500);
    } else {
      field.style.borderColor = '';
      errorDiv.classList.remove('show');
      updateButtonStates();
    }
  });
  
  document.getElementById('manualDeviceId').addEventListener('input', () => {
    const field = document.getElementById('manualDeviceId');
    const errorDiv = document.getElementById('manualDeviceIdError');
    if (field.value.trim()) {
      setTimeout(() => validateField('manualDeviceId'), 500);
    } else {
      field.style.borderColor = '';
      errorDiv.classList.remove('show');
      updateButtonStates();
    }
  });
  
  document.getElementById('pollInterval').addEventListener('input', () => {
    const field = document.getElementById('pollInterval');
    const errorDiv = document.getElementById('pollIntervalError');
    if (field.value.trim()) {
      setTimeout(() => validateField('pollInterval'), 500);
    } else {
      field.style.borderColor = '';
      errorDiv.classList.remove('show');
      updateButtonStates();
    }
  });
  
  // Handle login and discovery with smart credential validation
  document.getElementById('loginButton').addEventListener('click', async () => {
    const email = document.getElementById('email').value.trim();
    const password = document.getElementById('password').value;
    const countryCode = document.getElementById('countryCode').value;
    const manualToken = document.getElementById('manualToken').value.trim();
    const manualDeviceId = document.getElementById('manualDeviceId').value.trim();
    const apiServer = document.getElementById('apiServer').value.trim() || 'x107.omlet.co.uk';
    const pollInterval = parseInt(document.getElementById('pollInterval').value) || 30;
    const debugMode = document.getElementById('debugMode').checked;
    const enableLight = document.getElementById('enableLight').checked;
    const enableBattery = document.getElementById('enableBattery').checked;
    
    const loginButton = document.getElementById('loginButton');
    
    // Check if there are any validation errors showing
    const hasErrors = document.querySelector('.field-error.show') !== null;
    if (hasErrors) {
      showStatus('Please correct errors below before login.', 'error');
      return;
    }
    
    loginButton.disabled = true;
    hideStatus();
    
    try {
      // Determine what we have
      const hasToken = !!manualToken;
      const hasEmail = !!email;
      const hasPassword = !!password;
      const hasFullCreds = hasEmail && hasPassword;
      const hasPartialCreds = (hasEmail || hasPassword) && !hasFullCreds;
      const hasDeviceId = !!manualDeviceId;
      
      // === FLOW A: Invalid Inputs ===
      if (!hasToken && !hasFullCreds) {
        throw new Error('Email address and password is required');
      }
      
      let finalToken = null;
      let finalDeviceId = null;
      let shouldSaveCredentials = false;
      
      // === FLOW D: Token + Full Credentials (Token priority with fallback) ===
      if (hasToken && hasFullCreds) {
        shouldSaveCredentials = true;
        
        showStatus('Validating token...', 'info');
        loginButton.textContent = 'Validating...';
        
        const validateResult = await homebridge.request('/validate', {
          token: manualToken,
          deviceId: hasDeviceId ? manualDeviceId : null,
          debug: debugMode
        });
        
        if (validateResult.tokenValid) {
          // Token is valid, use it
          finalToken = manualToken;
          
          if (hasDeviceId) {
            if (validateResult.deviceValid) {
              finalDeviceId = manualDeviceId;
              showStatus('Token and Device ID validated successfully!', 'success');
            } else {
              // Device invalid, auto-discover
              if (validateResult.devices.length > 0) {
                discoveredDevices = validateResult.devices;
                displayDevices(discoveredDevices);
                finalDeviceId = discoveredDevices[0].deviceId;
                showStatus(`Invalid device ID. Successfully replaced with discovered device: ${discoveredDevices[0].name}`, 'success');
              } else {
                throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
              }
            }
          } else {
            // No device provided, discover
            if (validateResult.devices.length > 0) {
              discoveredDevices = validateResult.devices;
              displayDevices(discoveredDevices);
              finalDeviceId = discoveredDevices[0].deviceId;
              showStatus(`Success! Found ${discoveredDevices.length} device(s): ${discoveredDevices[0].name}`, 'success');
            } else {
              throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
            }
          }
        } else {
          // Token invalid, fall back to login
          showStatus('Token invalid, retrying with email/password...', 'info');
          loginButton.textContent = 'Logging in...';
          
          const loginResult = await homebridge.request('/login', {
            email: email,
            password: password,
            countryCode: countryCode,
            debug: debugMode
          });
          
          if (!loginResult.success || !loginResult.token) {
            throw new Error('Login has failed, please check email address and password and try again.');
          }
          
          finalToken = loginResult.token;
          
          // Now validate/discover device
          const validateResult2 = await homebridge.request('/validate', {
            token: finalToken,
            deviceId: hasDeviceId ? manualDeviceId : null,
            debug: debugMode
          });
          
          if (hasDeviceId) {
            if (validateResult2.deviceValid) {
              finalDeviceId = manualDeviceId;
              showStatus('Login successful! Device ID validated.', 'success');
            } else {
              if (validateResult2.devices.length > 0) {
                discoveredDevices = validateResult2.devices;
                displayDevices(discoveredDevices);
                finalDeviceId = discoveredDevices[0].deviceId;
                showStatus(`Login successful! Invalid device ID replaced with: ${discoveredDevices[0].name}`, 'success');
              } else {
                throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
              }
            }
          } else {
            if (validateResult2.devices.length > 0) {
              discoveredDevices = validateResult2.devices;
              displayDevices(discoveredDevices);
              finalDeviceId = discoveredDevices[0].deviceId;
              showStatus(`Login successful! Found device: ${discoveredDevices[0].name}`, 'success');
            } else {
              throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
            }
          }
        }
      }
      
      // === FLOW B: Token Only (may have partial creds, ignore them) ===
      else if (hasToken) {
        // Don't save partial credentials
        shouldSaveCredentials = false;
        
        showStatus('Validating token...', 'info');
        loginButton.textContent = 'Validating...';
        
        const validateResult = await homebridge.request('/validate', {
          token: manualToken,
          deviceId: hasDeviceId ? manualDeviceId : null,
          debug: debugMode
        });
        
        if (!validateResult.tokenValid) {
          throw new Error('Token is invalid, please try again or use email address and password.');
        }
        
        finalToken = manualToken;
        
        if (hasDeviceId) {
          if (validateResult.deviceValid) {
            finalDeviceId = manualDeviceId;
            showStatus('Token and Device ID validated successfully!', 'success');
          } else {
            // Device invalid, auto-discover
            if (validateResult.devices.length > 0) {
              discoveredDevices = validateResult.devices;
              displayDevices(discoveredDevices);
              finalDeviceId = discoveredDevices[0].deviceId;
              showStatus(`Invalid device ID. Successfully replaced with discovered device: ${discoveredDevices[0].name}`, 'success');
            } else {
              throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
            }
          }
        } else {
          // No device provided, discover
          if (validateResult.devices.length > 0) {
            discoveredDevices = validateResult.devices;
            displayDevices(discoveredDevices);
            finalDeviceId = discoveredDevices[0].deviceId;
            showStatus(`Success! Found ${discoveredDevices.length} device(s): ${discoveredDevices[0].name}`, 'success');
          } else {
            throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
          }
        }
      }
      
      // === FLOW C: Email+Password Only ===
      else if (hasFullCreds) {
        shouldSaveCredentials = true;
        
        showStatus('Logging in to Omlet...', 'info');
        loginButton.textContent = 'Logging in...';
        
        const loginResult = await homebridge.request('/login', {
          email: email,
          password: password,
          countryCode: countryCode
        });
        
        if (!loginResult.success || !loginResult.token) {
          throw new Error('Login has failed, please check email address and password and try again.');
        }
        
        finalToken = loginResult.token;
        
        // Now validate/discover device
        const validateResult = await homebridge.request('/validate', {
          token: finalToken,
          deviceId: hasDeviceId ? manualDeviceId : null
        });
        
        if (hasDeviceId) {
          if (validateResult.deviceValid) {
            finalDeviceId = manualDeviceId;
            showStatus('Login successful! Device ID validated.', 'success');
          } else {
            if (validateResult.devices.length > 0) {
              discoveredDevices = validateResult.devices;
              displayDevices(discoveredDevices);
              finalDeviceId = discoveredDevices[0].deviceId;
              showStatus(`Login successful! Invalid device ID replaced with: ${discoveredDevices[0].name}`, 'success');
            } else {
              throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
            }
          }
        } else {
          if (validateResult.devices.length > 0) {
            discoveredDevices = validateResult.devices;
            displayDevices(discoveredDevices);
            finalDeviceId = discoveredDevices[0].deviceId;
            showStatus(`Login successful! Found device: ${discoveredDevices[0].name}`, 'success');
          } else {
            throw new Error('No coop doors discovered. Please ensure your coop door is connected to your account and try again.');
          }
        }
      }
      
      // Save configuration
      // Build config explicitly (don't spread currentConfig - causes clone errors)
      const newConfig = {
        name: currentConfig.name || 'Omlet Coop',
        platform: 'OmletCoop',
        countryCode: countryCode,
        enableLight: enableLight,
        enableBattery: enableBattery,
        debug: debugMode
      };
      
      // Only include apiServer if user explicitly set it (not empty and not default)
      if (apiServer && apiServer !== 'x107.omlet.co.uk') {
        newConfig.apiServer = apiServer;
      }
      
      // Only include pollInterval if user explicitly set it (not empty/blank)
      if (pollInterval && pollInterval !== 30) {
        newConfig.pollInterval = pollInterval;
      }
      
      // CRITICAL: Only save token/deviceId to config if user MANUALLY entered them
      // Auto-discovered credentials are saved to storage by the plugin, not config
      
      // Save token to config ONLY if user manually provided it (not auto-discovered)
      if (hasToken && finalToken === manualToken) {
        // User manually entered this token → save to config
        newConfig.bearerToken = finalToken;
      } else {
        // Token was auto-discovered via email/password → don't save to config (goes to storage)
        delete newConfig.bearerToken;
      }
      
      // Save deviceId to config ONLY if user manually provided it (not auto-discovered)
      if (hasDeviceId && finalDeviceId === manualDeviceId) {
        // User manually entered this deviceId → save to config
        newConfig.deviceId = finalDeviceId;
      } else {
        // DeviceId was auto-discovered → don't save to config (goes to storage)
        delete newConfig.deviceId;
      }
      
      // Only save credentials if appropriate
      if (shouldSaveCredentials) {
        newConfig.email = email;
        newConfig.password = password;
      } else {
        // Clear credentials from config if not saving
        delete newConfig.email;
        delete newConfig.password;
      }
      
      // Debug: Log what we're about to save
      console.log('Saving config:', JSON.stringify(newConfig, null, 2));
      
      try {
        // Ensure config is JSON-serializable (fixes clone errors)
        const serializableConfig = JSON.parse(JSON.stringify(newConfig));
        await homebridge.updatePluginConfig([serializableConfig]);
        showStatus('Login successful! Click "Save" to apply changes.', 'success');
        loginButton.textContent = 'Login Successful ✓';
        loginButton.disabled = false;
      } catch (configError) {
        console.error('Config update error:', configError);
        throw new Error('Failed to update config: ' + configError.message);
      }
      
    } catch (error) {
      console.error('Error:', error);
      showStatus(`Error: ${error.message}`, 'error');
      loginButton.disabled = false;
      loginButton.textContent = 'Login';
    }
  });
  
  // Display discovered devices
  function displayDevices(devices) {
    const deviceList = document.getElementById('deviceList');
    const devicesSection = document.getElementById('devicesSection');
    
    deviceList.innerHTML = '';
    
    devices.forEach((device, index) => {
      const deviceDiv = document.createElement('div');
      deviceDiv.className = 'device-item';
      deviceDiv.innerHTML = `
        <h4>${device.name}</h4>
        <p><strong>Device ID:</strong> ${device.deviceId}</p>
        <p><strong>Type:</strong> ${device.type}</p>
        ${index === 0 ? '<p style="color: #28a745; font-weight: 500;">✓ This device will be used</p>' : ''}
      `;
      deviceList.appendChild(deviceDiv);
    });
    
    devicesSection.classList.remove('hidden');
  }
})();
</script>
